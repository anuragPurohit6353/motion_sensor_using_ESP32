/*
  ESP32-CAM Telegram Bot Project Code
  ------------------------------------
  This code connects an ESP32-CAM board to a WiFi network and sets up a Telegram bot.
  It enables the following functionalities:
    • Capture and send photos to a Telegram chat (with optional flash).
    • Control a relay to turn an external light on/off.
    • Use a PIR (motion) sensor to detect motion and trigger photo capture.
    • Read temperature and humidity using a DHT sensor.
  Detailed comments are provided next to each line or code block for clarity.
*/

#include <Arduino.h>                   // Core Arduino library: provides basic functions like setup() and loop()
#include <WiFi.h>                      // WiFi library: enables connection to wireless networks
#include <WiFiClientSecure.h>          // Secure WiFi client library: allows SSL/TLS connections (used for HTTPS communication)
#include "soc/soc.h"                   // SoC library: used for low-level system operations (e.g., disabling brownout)
#include "soc/rtc_cntl_reg.h"          // RTC control register definitions: used here to disable the brownout detector
#include "esp_camera.h"                // ESP32 camera library: provides functions to operate the built-in camera module
#include <UniversalTelegramBot.h>      // Telegram Bot API library: facilitates interacting with Telegram bots
#include <ArduinoJson.h>               // ArduinoJson library: helps with processing JSON (used with Telegram API responses)
#include <DHT.h>                       // DHT sensor library: enables reading temperature and humidity from DHT sensors

// WiFi network credentials for connection
const char* ssid = "WiFi SSID (network name)";             // WiFi SSID (network name)
const char* password = " WiFi password";                   // WiFi password

// Telegram bot configuration: token and target chat ID
String BOTtoken = "9090909090:AAG9m9MZbl91aypEOm0M5VvzO4IaVVO9MqQ"; // Bot token generated by BotFather
String CHAT_ID = "3445345354";         // The Telegram chat ID to which messages and photos will be sent

// Flags to manage project functionalities
bool sendPhoto = false;                // Flag to indicate a pending photo capture request
bool withFlash = false;                // Flag to enable flash mode when capturing a photo
bool motionSensorFlag = false;         // Flag indicating whether the motion sensor (PIR) is active

// Secure WiFi client object for handling HTTPS connections to Telegram
WiFiClientSecure clientTCP;
// Telegram bot object constructed with the bot token and secure WiFi client
UniversalTelegramBot bot(BOTtoken, clientTCP);

// Define GPIO pins for various functions
#define FLASH_LED_PIN 4              // GPIO used to control the flash LED for photography
#define PIR 13                       // GPIO input pin connected to the PIR motion sensor
#define RELAY 12                     // GPIO controlling the relay to switch a light on/off
#define DHTPIN 2                     // GPIO pin connected to the DHT sensor data line
#define DHTTYPE DHT11                // Define the DHT sensor type (DHT11 in this case)

// Create a DHT sensor object to read temperature and humidity values
DHT dht(DHTPIN, DHTTYPE);

// Define camera module pins (specific to the AI Thinker ESP32-CAM model)
#define PWDN_GPIO_NUM     32         // Power-down pin for the camera (used to turn the camera off when not in use)
#define RESET_GPIO_NUM    -1         // Reset pin for the camera (set to -1 as it is not used in this configuration)
#define XCLK_GPIO_NUM      0         // External clock pin: provides clock signal for the camera sensor
#define SIOD_GPIO_NUM     26         // SDA pin for the SCCB (Serial Camera Control Bus) used for camera configuration
#define SIOC_GPIO_NUM     27         // SCL pin for the SCCB: clock line for camera control
#define Y9_GPIO_NUM       35         // Data pin Y9: used for camera image data output
#define Y8_GPIO_NUM       34         // Data pin Y8: used for camera image data output
#define Y7_GPIO_NUM       39         // Data pin Y7: used for camera image data output
#define Y6_GPIO_NUM       36         // Data pin Y6: used for camera image data output
#define Y5_GPIO_NUM       21         // Data pin Y5: used for camera image data output
#define Y4_GPIO_NUM       19         // Data pin Y4: used for camera image data output
#define Y3_GPIO_NUM       18         // Data pin Y3: used for camera image data output
#define Y2_GPIO_NUM        5         // Data pin Y2: used for camera image data output
#define VSYNC_GPIO_NUM    25         // VSYNC pin: synchronizes the start of a new frame from the camera
#define HREF_GPIO_NUM     23         // HREF pin: indicates the valid portion of a line of video data
#define PCLK_GPIO_NUM     22         // PCLK pin: pixel clock signal used by the camera module

// Variables for Telegram bot request timing control
int botRequestDelay = 1000;            // Delay (in milliseconds) between consecutive checks for new bot messages
unsigned long lastTimeBotRan;          // Timestamp of the last update cycle for the bot

// Function to initialize and configure the ESP32-CAM camera module with specific settings
void configInitCamera() {
  // Create and populate the camera configuration structure
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;              // Use LEDC channel 0 for camera (PWM for XCLK)
  config.ledc_timer = LEDC_TIMER_0;                  // Use LEDC timer 0 for PWM timing
  config.pin_d0 = Y2_GPIO_NUM;                       // Assign data pin D0 (Y2)
  config.pin_d1 = Y3_GPIO_NUM;                       // Assign data pin D1 (Y3)
  config.pin_d2 = Y4_GPIO_NUM;                       // Assign data pin D2 (Y4)
  config.pin_d3 = Y5_GPIO_NUM;                       // Assign data pin D3 (Y5)
  config.pin_d4 = Y6_GPIO_NUM;                       // Assign data pin D4 (Y6)
  config.pin_d5 = Y7_GPIO_NUM;                       // Assign data pin D5 (Y7)
  config.pin_d6 = Y8_GPIO_NUM;                       // Assign data pin D6 (Y8)
  config.pin_d7 = Y9_GPIO_NUM;                       // Assign data pin D7 (Y9)
  config.pin_xclk = XCLK_GPIO_NUM;                   // Configure the external clock pin for the camera
  config.pin_pclk = PCLK_GPIO_NUM;                   // Set the pixel clock pin for synchronizing data transfer
  config.pin_vsync = VSYNC_GPIO_NUM;                 // Set the vertical sync pin
  config.pin_href = HREF_GPIO_NUM;                   // Set the horizontal reference pin
  config.pin_sscb_sda = SIOD_GPIO_NUM;               // Set SCCB data line for the camera control bus
  config.pin_sscb_scl = SIOC_GPIO_NUM;               // Set SCCB clock line for the camera control bus
  config.pin_pwdn = PWDN_GPIO_NUM;                   // Configure the power-down pin to control camera power
  config.pin_reset = RESET_GPIO_NUM;                 // Set the reset pin (unused in this configuration)
  config.xclk_freq_hz = 20000000;                    // Set the external clock frequency to 20 MHz for the camera
  config.pixel_format = PIXFORMAT_JPEG;              // Set the pixel format to JPEG for image compression

  // Adjust camera settings based on available memory (PSRAM)
  if (psramFound()){
    config.frame_size = FRAMESIZE_QVGA;              // Use QVGA resolution when PSRAM is available (better performance)
    config.jpeg_quality = 8;                         // Set JPEG quality (lower value means higher quality)
    config.fb_count = 2;                             // Use two frame buffers for smoother capture
  } else {
    config.frame_size = FRAMESIZE_QVGA;              // Use QVGA resolution when PSRAM is not available
    config.jpeg_quality = 8;                         // Set JPEG quality
    config.fb_count = 1;                             // Use one frame buffer to conserve memory
  }

  // Initialize the camera with the provided configuration
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {                               // If initialization fails,
    Serial.printf("Camera init failed with error 0x%x", err); // Output the specific error code for debugging
    delay(1000);                                   // Wait for 1 second before attempting a restart
    ESP.restart();                                 // Restart the ESP32 to try and recover from the error
  }

  // Retrieve the camera sensor object to further configure sensor settings if needed
  sensor_t * s = esp_camera_sensor_get();
  s->set_framesize(s, FRAMESIZE_QVGA);               // Ensure the frame size is set correctly (QVGA)
}

// Function to read temperature and humidity from the DHT sensor and return a formatted string
String getWeather(){
  float h = dht.readHumidity();                    // Read the humidity level from the DHT sensor
  float t = dht.readTemperature();                 // Read the temperature value in °C from the DHT sensor
  if (isnan(h) || isnan(t)) {                        // Check if the reading failed (NaN value indicates an error)
    return "Failed to read from DHT sensor! /weather"; // Return an error message if sensor data is invalid
  }
  // Construct and return a status message with temperature and humidity information
  return "Temperature: " + String(t) + "°C Humidity: " + String(h) + "% /weather";
}

// Function to turn the relay (and thus the connected light) ON and return a status message
String lightOn(){  
  if (digitalRead(RELAY)) {                        // Check if the relay is already activated (light already ON)
    return "Light is already ON. /lightOff";       // Inform the user and suggest the command to turn it off
  }
  digitalWrite(RELAY, HIGH);                       // Set the relay pin HIGH to turn the light ON
  delay(100);                                      // Brief delay to ensure the state change occurs
  return "Light is ON. /lightOff";                 // Return a confirmation message
}

// Function to turn the relay (and connected light) OFF and return a status message
String lightOff(){  
  if (!digitalRead(RELAY)) {                       // Check if the relay is already off (light already OFF)
    return "Light is already OFF. /lightOn";       // Inform the user and suggest the command to turn it ON
  }
  digitalWrite(RELAY, LOW);                        // Set the relay pin LOW to turn the light OFF
  delay(100);                                      // Brief delay to ensure the state change occurs
  return "Light is OFF. /lightOn";                 // Return a confirmation message
}

// Function to capture a photo with the camera and send it to Telegram as a photo message
String sendPhotoTelegram() {
  const char* myDomain = "api.telegram.org";       // Telegram API domain for sending photos
  String getAll = "", getBody = "";                // Variables to store response headers and body from the HTTP response

  // If flash mode is enabled, turn on the flash LED and also activate the relay (if used as additional lighting)
  if (withFlash) {
    digitalWrite(FLASH_LED_PIN, HIGH);             // Turn ON flash LED
    digitalWrite(RELAY, HIGH);                     // Turn ON light via relay
    delay(200);                                    // Wait briefly to let the flash light up
  }

  // Capture an image using the ESP32-CAM and get a pointer to the frame buffer
  camera_fb_t * fb = esp_camera_fb_get();          
  if (!fb) {                                       // Check if the image capture failed
    Serial.println("Camera capture failed");       // Log the error to the serial monitor
    delay(1000);                                   // Delay to allow any transient issues to resolve
    ESP.restart();                                 // Restart ESP32 to recover from the error
    return "Camera capture failed";                // Return an error message (this line is precautionary after restart)
  }  

  // Attempt to establish a secure connection to the Telegram API
  if (clientTCP.connect(myDomain, 443)) {
    // Construct the multipart HTTP request header and tail for sending photo data
    String head = "--RandomNerdTutorials\r\nContent-Disposition: form-data; name=\"chat_id\"; \r\n\r\n" 
                  + CHAT_ID + "\r\n--RandomNerdTutorials\r\nContent-Disposition: form-data; name=\"photo\"; filename=\"esp32-cam.jpg\"\r\nContent-Type: image/jpeg\r\n\r\n";
    String tail = "\r\n--RandomNerdTutorials--\r\n";

    // Calculate the total length of the HTTP POST content (image size plus header and tail)
    uint16_t imageLen = fb->len;                   // Length of the captured image data
    uint16_t extraLen = head.length() + tail.length(); // Combined length of header and tail strings
    uint16_t totalLen = imageLen + extraLen;         // Total length of the POST request body

    // Begin constructing the HTTP POST request to Telegram's sendPhoto endpoint
    clientTCP.println("POST /bot" + BOTtoken + "/sendPhoto HTTP/1.1"); // Specify POST request with the bot token in the URL
    clientTCP.println("Host: " + String(myDomain));  // Include the Host header as required in HTTP/1.1
    clientTCP.println("Content-Length: " + String(totalLen)); // Specify the Content-Length of the request body
    clientTCP.println("Content-Type: multipart/form-data; boundary=RandomNerdTutorials"); // Set the content type with the defined boundary
    clientTCP.println();                           // End of HTTP headers
    clientTCP.print(head);                         // Send the multipart header part

    // Write the image data from the frame buffer to the client in 1024-byte chunks
    uint8_t *fbBuf = fb->buf;                      // Pointer to the image byte array
    size_t fbLen = fb->len;                        // Length of the image data
    for (size_t n = 0; n < fbLen; n += 1024) {       // Loop over the image buffer in increments of 1024 bytes
      if (n + 1024 < fbLen) {                      // If there is at least 1024 bytes remaining,
        clientTCP.write(fbBuf, 1024);              // Write 1024 bytes to the HTTP request
        fbBuf += 1024;                           // Move the pointer ahead by 1024 bytes
      } else if (fbLen % 1024 > 0) {               // Handle any remaining bytes less than 1024
        size_t remainder = fbLen % 1024;           // Determine the number of remaining bytes
        clientTCP.write(fbBuf, remainder);         // Write the remaining bytes
      }
    }
    clientTCP.print(tail);                         // Send the multipart tail to finish the request
    esp_camera_fb_return(fb);                      // Return the frame buffer to free its memory

    // Wait and read the response from the Telegram server
    int waitTime = 10000;                          // Maximum wait time (in milliseconds) for a response
    long startTimer = millis();                    // Record the start time of the response waiting period
    boolean state = false;                         // State flag to indicate if headers are finished processing

    // Loop until a response is received or timeout occurs
    while ((startTimer + waitTime) > millis()) {
      Serial.print(".");                           // Print a dot for each iteration (progress indicator)
      delay(100);                                  // Short delay to avoid overwhelming the processor
      while (clientTCP.available()) {              // Check if data is available from the server
        char c = clientTCP.read();                 // Read one character from the server's response
        if (state) getBody += String(c);           // Once headers are finished, append the character to the response body
        if (c == '\n') {                           // Newline indicates the end of a header line
          if (getAll.length() == 0) state = true;    // Transition to reading the body when an empty header line is encountered
          getAll = "";                             // Reset the temporary header string
        } else if (c != '\r')                      // Skip carriage return characters
          getAll += String(c);                     // Accumulate header text
        startTimer = millis();                     // Update timer on receiving any data to prevent premature timeout
      }
      if (getBody.length() > 0) break;             // Exit the loop once the response body is read
    }
    clientTCP.stop();                              // Close the TCP connection after finishing the request
  } else {
    getBody = "Connected to api.telegram.org failed."; // Set error message if connection fails
  }

  // If flash mode was active, turn off the flash LED and relay after sending the photo
  if (withFlash) {
    digitalWrite(FLASH_LED_PIN, LOW);              // Turn OFF flash LED
    digitalWrite(RELAY, LOW);                      // Turn OFF the relay (and connected light)
    withFlash = false;                             // Reset the flash flag for future operations
  }
  return getBody;                                  // Return the server's response (or error message)
}

// Function to process new messages received from the Telegram bot
void handleNewMessages(int numNewMessages) {
  Serial.print("Handle New Messages: ");           // Print a label to the serial monitor
  Serial.println(numNewMessages);                  // Output the number of new messages received

  // Loop through each new message
  for (int i = 0; i < numNewMessages; i++) {
    String chat_id = String(bot.messages[i].chat_id); // Get the chat ID of the incoming message
    if (chat_id != CHAT_ID) {                      // If the message did not come from the authorized chat,
      bot.sendMessage(chat_id, "Unauthorized user", ""); // notify the sender that they are unauthorized
      continue;                                    // Skip processing for unauthorized messages
    }

    // Retrieve the text content and sender's name from the message
    String text = bot.messages[i].text;
    String from_name = bot.messages[i].from_name;

    // Process the "/start" command: send a welcome message with available commands
    if (text == "/start") {
      String welcome = "Welcome, " + from_name + "\n";    // Greet the user by name
      welcome += "Use the following commands:\n";          // List the available commands
      welcome += "/photo : takes a new photo\n";           // Explain photo command
      welcome += "/photoWithFlash : takes photo with flash\n"; // Explain photo with flash command
      welcome += "/flash : toggles flash LED\n";           // Explain flash toggle command
      welcome += "/lightOn : turn light ON\n";             // Explain light ON command
      welcome += "/lightOff : turn light OFF\n";           // Explain light OFF command
      welcome += "/motionOn : enable motion sensor\n";     // Explain motion sensor enable command
      welcome += "/motionOff : disable motion sensor\n";   // Explain motion sensor disable command
      welcome += "/weather : get temperature & humidity\n"; // Explain weather command
      bot.sendMessage(CHAT_ID, welcome, "");              // Send the welcome message to the authorized chat
    }
    // Toggle the flash LED state on receiving the "/flash" command
    if (text == "/flash") {
      digitalWrite(FLASH_LED_PIN, !digitalRead(FLASH_LED_PIN)); // Toggle the state (ON/OFF) of the flash LED
      Serial.println("Flash LED toggled");             // Log the action on the serial monitor
    }
    // When the "/photo" command is received, set the flag to capture a photo without flash
    if (text == "/photo") {
      sendPhoto = true;                                // Set flag to capture photo
      Serial.println("New photo request");             // Output debug message
    }
    // When the "/photoWithFlash" command is received, set the flags to capture a photo with flash enabled
    if (text == "/photoWithFlash") {
      sendPhoto = true;                                // Set flag to capture photo
      withFlash = true;                                // Enable flash mode for photo capture
      Serial.println("New photo with flash request");  // Output debug message
    }
    // Process the "/lightOn" command to turn on the light via relay
    if (text == "/lightOn") {
      bot.sendMessage(CHAT_ID, lightOn(), "");         // Call lightOn(), then send its returned message back to Telegram
    }
    // Process the "/lightOff" command to turn off the light via relay
    if (text == "/lightOff") {
      bot.sendMessage(CHAT_ID, lightOff(), "");        // Call lightOff(), then send its returned message back to Telegram
    }
    // When "/motionOn" command is received, enable the motion sensor checking
    if (text == "/motionOn") {
      motionSensorFlag = true;                         // Enable the motion sensor flag
      bot.sendMessage(CHAT_ID, "Motion Sensor ON. /motionOff", ""); // Notify the user that motion detection is active
    }
    // When "/motionOff" command is received, disable the motion sensor checking
    if (text == "/motionOff") {
      motionSensorFlag = false;                        // Disable the motion sensor flag
      bot.sendMessage(CHAT_ID, "Motion Sensor OFF. /motionOn", ""); // Notify the user that motion detection is off
    }
    // Respond to the "/weather" command by sending temperature and humidity readings
    if (text == "/weather") {
      bot.sendMessage(CHAT_ID, getWeather(), "");      // Call getWeather() and send its response as a Telegram message
    }
  }
}

// The setup function runs once when the device is powered on or reset
void setup(){
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);         // Disable the brownout detector to avoid unexpected resets during high-power tasks
  Serial.begin(115200);                              // Start serial communication at 115200 baud for debugging

  // Configure the pin modes for the flash LED, relay, and PIR sensor
  pinMode(FLASH_LED_PIN, OUTPUT);                    // Set the flash LED pin as an output
  pinMode(RELAY, OUTPUT);                            // Set the relay pin as an output
  pinMode(PIR, INPUT_PULLUP);                        // Set the PIR sensor pin as an input with internal pull-up resistor enabled
  digitalWrite(FLASH_LED_PIN, LOW);                  // Ensure the flash LED is initially OFF
  digitalWrite(RELAY, LOW);                          // Ensure the relay (and thus the light) is initially OFF

  configInitCamera();                                // Initialize and configure the ESP32-CAM module
  dht.begin();                                       // Initialize the DHT sensor to prepare for temperature/humidity readings

  WiFi.mode(WIFI_STA);                               // Set WiFi mode to Station mode (client mode)
  Serial.print("Connecting to ");                    // Debug: print message indicating WiFi connection is starting
  Serial.println(ssid);                              // Display the SSID of the network to which the device is connecting
  WiFi.begin(ssid, password);                        // Begin connecting to the specified WiFi network with provided credentials
  clientTCP.setCACert(TELEGRAM_CERTIFICATE_ROOT);    // Set the root certificate for Telegram for HTTPS verification
  while (WiFi.status() != WL_CONNECTED) {            // Loop until a successful WiFi connection is established
    Serial.print(".");                               // Print dots to indicate the connection process is ongoing
    delay(500);                                      // Wait for half a second before checking again
  }
  Serial.println();                                  // New line after successful connection
  Serial.print("ESP32-CAM IP Address: ");            // Output a message to show the device's assigned local IP address
  Serial.println(WiFi.localIP());                    // Display the IP address obtained from the WiFi connection
}

// The loop function runs repeatedly after the setup is complete
void loop() {
  // If a photo capture request is active, take the photo and send it via Telegram
  if (sendPhoto) {
    Serial.println("Preparing photo");               // Debug message: indicate that photo capture is starting
    sendPhotoTelegram();                             // Call function to capture and send the photo
    sendPhoto = false;                               // Reset the photo request flag after processing
  }
  
  // If the motion sensor is active and detects motion, capture a photo
  if (motionSensorFlag && digitalRead(PIR) == LOW) {
    Serial.println("Motion Detected");               // Debug message: indicate motion detection
    sendPhotoTelegram();                             // Call function to capture and send the photo triggered by motion
    delay(1000);                                     // Delay for 1 second to prevent multiple rapid triggers
  }

  // Check for new messages from the Telegram bot at regular intervals defined by botRequestDelay
  if (millis() > lastTimeBotRan + botRequestDelay) {
    int numNewMessages = bot.getUpdates(bot.last_message_received + 1); // Retrieve new messages since the last processed message
    while (numNewMessages) {                           // Process all new messages
      Serial.println("got response");                // Debug message indicating a response was received
      handleNewMessages(numNewMessages);               // Process the received messages
      numNewMessages = bot.getUpdates(bot.last_message_received + 1); // Check if there are further messages to process
    }
    lastTimeBotRan = millis();                         // Update the time stamp for the last check
  }
}